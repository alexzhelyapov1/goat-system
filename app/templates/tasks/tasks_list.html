{% extends "base.html" %}

{% block content %}
    <h1>Tasks</h1>
    <div class="d-flex justify-content-between mb-3">
        <div>
            <button class="btn btn-primary filter-btn" data-filter="all" onclick="filterTasks('all')">All</button>
            <button class="btn btn-secondary filter-btn" data-filter="INBOX" onclick="filterTasks('INBOX')">Inbox</button>
            <button class="btn btn-secondary filter-btn" data-filter="CURRENT" onclick="filterTasks('CURRENT')">Current</button>
            <button class="btn btn-secondary filter-btn" data-filter="SOMEDAY" onclick="filterTasks('SOMEDAY')">Someday</button>
            <button class="btn btn-secondary filter-btn" data-filter="REST" onclick="filterTasks('REST')">Rest</button>
            <button class="btn btn-secondary filter-btn" data-filter="ROUTINE" onclick="filterTasks('ROUTINE')">Routine</button>
        </div>
        <a href="#" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#taskModal" data-task-id="create">Create Task</a>
        <button type="button" class="btn btn-secondary" data-bs-toggle="modal" data-bs-target="#exportTasksModal">
            Export
        </button>
        <button type="button" class="btn btn-info" data-bs-toggle="modal" data-bs-target="#importTasksModal">
            Import
        </button>
    </div>
    <div class="list-group">

    <!-- Import Modal -->
    <div class="modal fade" id="importTasksModal" tabindex="-1" aria-labelledby="importTasksModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="importTasksModalLabel">Import Tasks</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <form action="{{ url_for('tasks.import_tasks') }}" method="post" enctype="multipart/form-data">
                    <div class="modal-body">
                        <div class="mb-3">
                            <label for="file" class="form-label">Select JSON file</label>
                            <input class="form-control" type="file" name="file" id="file" accept=".json">
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        <button type="submit" class="btn btn-primary">Import</button>
                    </div>
                </form>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div class="modal fade" id="exportTasksModal" tabindex="-1" aria-labelledby="exportTasksModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="exportTasksModalLabel">Export Tasks</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <p>Select fields to export:</p>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" value="title" id="export-title" checked>
                        <label class="form-check-label" for="export-title">
                            Title
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" value="status" id="export-status">
                        <label class="form-check-label" for="export-status">
                            Status
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" value="type" id="export-type" checked>
                        <label class="form-check-label" for="export-type">
                            Type
                        </label>
                    </div>
                    <div class="form-check">
                        <input class="form-check-input" type="checkbox" value="details" id="export-details">
                        <label class="form-check-label" for="export-details">
                            Details
                        </label>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" id="export-tasks-btn">Export</button>
                </div>
            </div>
        </div>
    </div>

    <div class="list-group" id="tasks-list-container">
    </div>

    <!-- Modal -->
    <div class="modal fade" id="taskModal" tabindex="-1" aria-labelledby="taskModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="taskModalLabel">Edit Task</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
            <form action="" method="post" novalidate id="task-modal-form">
                {% include 'tasks/_task_form.html' %}
            </form>
          </div>
          <div class="modal-footer">
            <button type="button" id="delete-task-btn" class="btn btn-danger me-auto">Delete</button>
            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            <button type="submit" form="task-modal-form" class="btn btn-primary">Save changes</button>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script>
        // Global variables for task management
        let currentFilter = 'all'; // Default filter
        let currentTaskId = null; // Used for modal context (edit/delete)

        // Helper function to get auth headers
        function getAuthHeaders() {
            if (window.jwt_token) {
                return {
                    'Authorization': `Bearer ${window.jwt_token}`,
                    'Content-Type': 'application/json'
                };
            }
            return {'Content-Type': 'application/json'};
        }

        // --- Task Fetching and Rendering ---
        async function fetchTasks(taskType = 'all') {
            // Update filter button styles
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-secondary');
            });
            const activeButton = document.querySelector(`.filter-btn[data-filter="${taskType}"]`);
            if (activeButton) {
                activeButton.classList.remove('btn-secondary');
                activeButton.classList.add('btn-primary');
            }

            if (!window.jwt_token) {
                console.warn("JWT not available. Cannot fetch tasks.");
                return;
            }
            currentFilter = taskType;
            const tasksListContainer = document.getElementById('tasks-list-container');
            tasksListContainer.innerHTML = 'Loading tasks...';

            try {
                let url = '/api/tasks';
                if (taskType !== 'all') {
                    url += `?task_type=${taskType}`;
                }
                const response = await fetch(url, {
                    method: 'GET',
                    headers: getAuthHeaders()
                });

                if (!response.ok) {
                    throw new Error(`Failed to fetch tasks: ${response.statusText}`);
                }

                const tasks = await response.json();
                renderTasks(tasks);
            } catch (error) {
                console.error("Error fetching tasks:", error);
                tasksListContainer.innerHTML = '<div class="alert alert-danger">Error loading tasks. Please try again.</div>';
            }
        }

        function renderTasks(tasks) {
            const tasksListContainer = document.getElementById('tasks-list-container');
            tasksListContainer.innerHTML = ''; // Clear previous tasks

            if (tasks.length === 0) {
                tasksListContainer.innerHTML = '<div class="alert alert-info">No tasks found for this filter.</div>';
                return;
            }

            tasks.forEach(task => {
                let itemClass = '';
                if (task.type === 'INBOX') itemClass = 'list-group-item-inbox';
                else if (task.type === 'ROUTINE') itemClass = 'list-group-item-routine';
                else if (task.type === 'CURRENT') itemClass = 'list-group-item-current';

                const taskElement = `
                    <div class="list-group-item ${itemClass}">
                        <div class="d-flex w-100 justify-content-between">
                            <a href="#" class="text-decoration-none text-dark flex-grow-1 task-edit-link" data-bs-toggle="modal" data-bs-target="#taskModal" data-task-id="${task.id}">
                                <h5 class="mb-1">${task.title}</h5>
                                <small>${task.type}</small>
                            </a>
                            <button class="btn btn-danger btn-sm" onclick="deleteTask(${task.id})">Delete</button>
                        </div>
                    </div>
                `;
                tasksListContainer.innerHTML += taskElement;
            });
        }

        // --- Task Deletion ---
        async function deleteTask(taskId) {
            if (!confirm('Are you sure you want to delete this task?')) {
                return;
            }
            try {
                const response = await fetch(`/api/tasks/${taskId}`, {
                    method: 'DELETE',
                    headers: getAuthHeaders()
                });

                if (!response.ok) {
                    throw new Error(`Failed to delete task: ${response.statusText}`);
                }
                // Refresh tasks after deletion
                fetchTasks(currentFilter);
            } catch (error) {
                console.error("Error deleting task:", error);
                alert('Error deleting task.');
            }
        }

        // --- Task Modal Handling (Create/Edit) ---
        document.addEventListener('DOMContentLoaded', function () {
            const taskModal = document.getElementById('taskModal');
            const taskModalForm = document.getElementById('task-modal-form');
            const detailsDisplay = taskModal.querySelector('#details-display');
            const detailsTextarea = taskModal.querySelector('#details');
            const deleteTaskBtn = document.getElementById('delete-task-btn');
            const fullPageEditLink = document.getElementById('full-page-edit-link');
            const modalTitle = taskModal.querySelector('.modal-title');
            
            // Initial render for markdown preview
            if (detailsDisplay && detailsTextarea) {
                detailsDisplay.innerHTML = marked.parse(detailsTextarea.value);
            }

            function autoResizeTextarea(textarea) {
                textarea.style.height = 'auto';
                textarea.style.height = (textarea.scrollHeight) + 'px';
            }

            // Markdown editor logic for the modal form
            if (detailsDisplay && detailsTextarea) {
                detailsDisplay.addEventListener('click', () => {
                    detailsDisplay.classList.add('d-none');
                    detailsTextarea.classList.remove('d-none');
                    detailsTextarea.focus();
                    autoResizeTextarea(detailsTextarea);
                });

                detailsTextarea.addEventListener('blur', () => {
                    detailsDisplay.classList.remove('d-none');
                    detailsTextarea.classList.add('d-none');
                    detailsDisplay.innerHTML = marked.parse(detailsTextarea.value);
                });

                detailsTextarea.addEventListener('input', () => {
                    autoResizeTextarea(detailsTextarea);
                });
            }

            // Handle modal opening
            taskModal.addEventListener('show.bs.modal', async function (event) {
                const button = event.relatedTarget;
                const taskId = button.getAttribute('data-task-id');
                currentTaskId = taskId; // Set global currentTaskId

                taskModalForm.reset(); // Reset form for new data
                if (detailsDisplay && detailsTextarea) {
                    detailsTextarea.value = '';
                    detailsDisplay.innerHTML = '';
                }

                if (taskId === 'create') {
                    modalTitle.textContent = 'Create Task';
                    fullPageEditLink.href = '#'; // No full page for create via modal
                    deleteTaskBtn.style.display = 'none';
                } else {
                    modalTitle.textContent = `Edit Task ${taskId}`;
                    fullPageEditLink.href = `/task/${taskId}`; // Keep Flask link for full page edit (or replace later)
                    deleteTaskBtn.style.display = 'block';

                    try {
                        const response = await fetch(`/api/tasks/${taskId}`, {
                            method: 'GET',
                            headers: getAuthHeaders()
                        });

                        if (!response.ok) {
                            throw new Error(`Failed to fetch task: ${response.statusText}`);
                        }
                        const data = await response.json();
                        taskModalForm.title.value = data.title || '';
                        taskModalForm.status.value = data.status || 'OPEN';
                        taskModalForm.type.value = data.type || 'INBOX';
                        taskModalForm.duration.value = data.duration || '';
                        taskModalForm.details.value = data.details || '';

                        // Update markdown display
                        if (detailsDisplay && detailsTextarea) {
                            detailsTextarea.value = data.details || '';
                            detailsDisplay.innerHTML = marked.parse(detailsTextarea.value);
                        }

                        function setLocalTimeValue(dateString, dateInput, timeInput) {
                            if (dateString) {
                                const date = new Date(dateString.endsWith('Z') || dateString.includes('+') ? dateString : dateString + 'Z');
                                const year = date.getFullYear();
                                const month = String(date.getMonth() + 1).padStart(2, '0');
                                const day = String(date.getDate()).padStart(2, '0');
                                dateInput.value = `${year}-${month}-${day}`;

                                const hours = String(date.getHours()).padStart(2, '0');
                                const minutes = String(date.getMinutes()).padStart(2, '0');
                                timeInput.value = `${hours}:${minutes}`;
                            } else {
                                dateInput.value = '';
                                timeInput.value = '';
                            }
                        }

                        setLocalTimeValue(data.deadline, taskModalForm.deadline_date, taskModalForm.deadline_time);
                        setLocalTimeValue(data.planned_start, taskModalForm.planned_start_date, taskModalForm.planned_start_time);
                        setLocalTimeValue(data.planned_end, taskModalForm.planned_end_date, taskModalForm.planned_end_time);
                        setLocalTimeValue(data.suspend_due, taskModalForm.suspend_due_date, taskModalForm.suspend_due_time);
                        setLocalTimeValue(data.notify_at, taskModalForm.notify_at_date, taskModalForm.notify_at_time);

                    } catch (error) {
                        console.error('Error fetching task data:', error);
                        alert('Error loading task data.');
                    }
                }
            });

            // Handle form submission (Create/Update)
            taskModalForm.addEventListener('submit', async function (event) {
                event.preventDefault(); // Prevent default form submission

                if (!window.jwt_token) {
                    alert("Authentication token not available. Please log in again.");
                    return;
                }

                const formData = new FormData(taskModalForm);
                const taskData = Object.fromEntries(formData.entries());

                // Prepare data for FastAPI
                const payload = {
                    title: taskData.title,
                    status: taskData.status,
                    type: taskData.type,
                    details: taskData.details,
                    duration: taskData.duration ? parseInt(taskData.duration, 10) : null
                };

                const dateFields = ['deadline', 'planned_start', 'planned_end', 'suspend_due', 'notify_at'];

                dateFields.forEach(field => {
                    const dateValue = taskData[`${field}_date`];
                    const timeValue = taskData[`${field}_time`];

                    if (dateValue) {
                        // Combine date and time to ISO format that Pydantic can parse
                        const combinedDateTime = `${dateValue}T${timeValue || '00:00:00'}`;
                        payload[field] = combinedDateTime;
                    } else {
                        payload[field] = null;
                    }
                });

                let url = '/api/tasks';
                let method = 'POST';

                if (currentTaskId !== 'create') {
                    url = `/api/tasks/${currentTaskId}`;
                    method = 'PUT';
                }

                try {
                    const response = await fetch(url, {
                        method: method,
                        headers: getAuthHeaders(),
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(`Failed to save task: ${JSON.stringify(errorData)}`);
                    }

                    // Task saved successfully, close modal and refresh list
                    const bsModal = bootstrap.Modal.getInstance(taskModal);
                    bsModal.hide();
                    fetchTasks(currentFilter);
                } catch (error) {
                    console.error("Error saving task:", error);
                    alert(`Error saving task: ${error.message}`);
                }
            });

            // --- Export Tasks ---
            const exportTasksModalEl = document.getElementById('exportTasksModal');
            const exportTasksModal = new bootstrap.Modal(exportTasksModalEl);
            const exportTasksBtn = document.getElementById('export-tasks-btn');

            exportTasksBtn.addEventListener('click', async function() {
                if (!window.jwt_token) {
                    alert("Authentication token not available. Please log in again.");
                    return;
                }

                const selectedFields = [];
                const checkboxes = document.querySelectorAll('#exportTasksModal .form-check-input');
                checkboxes.forEach(function(checkbox) {
                    if (checkbox.checked && checkbox.value !== 'on') { // Exclude default checkbox value
                        selectedFields.push(checkbox.value);
                    }
                });

                const queryString = selectedFields.map(field => 'fields=' + field).join('&');
                
                try {
                    const response = await fetch('/tasks/export?' + queryString, { // Still using Flask for export as it handles blob directly
                        method: 'GET',
                        headers: getAuthHeaders() // Pass JWT even to Flask if it expects it
                    });

                    if (!response.ok) {
                        throw new Error(`Failed to export tasks: ${response.statusText}`);
                    }

                    const blob = await response.blob();
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'tasks.json';
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    exportTasksModal.hide();
                } catch (error) {
                    console.error("Error exporting tasks:", error);
                    alert('Error exporting tasks.');
                }
            });

            // --- Import Tasks ---
            const importTasksModalEl = document.getElementById('importTasksModal');
            const importTasksModal = new bootstrap.Modal(importTasksModalEl);
            const importTasksForm = document.querySelector('#importTasksModal form');

            importTasksForm.addEventListener('submit', async function(event) {
                event.preventDefault();
                if (!window.jwt_token) {
                    alert("Authentication token not available. Please log in again.");
                    return;
                }

                const formData = new FormData(importTasksForm);
                const fileInput = formData.get('file');

                if (!fileInput || fileInput.size === 0) {
                    alert('Please select a JSON file to import.');
                    return;
                }

                try {
                    const fileContent = await fileInput.text();
                    const tasksToImport = JSON.parse(fileContent);

                    for (const taskData of tasksToImport) {
                        // Clean up task_data to match TaskCreate schema
                        const payload = {};
                        for (const key in taskData) {
                            if (taskData.hasOwnProperty(key) && ['title', 'details', 'status', 'type', 'deadline', 'duration', 'planned_start', 'planned_end', 'suspend_due', 'notify_at'].includes(key)) {
                                payload[key] = taskData[key];
                            }
                        }
                        // Ensure required fields are present if not in import
                        payload.title = payload.title || 'Imported Task';
                        // FastAPI will validate against TaskCreate schema

                        const response = await fetch('/api/tasks', {
                            method: 'POST',
                            headers: getAuthHeaders(),
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(`Failed to import task: ${JSON.stringify(errorData)}`);
                        }
                    }

                    alert('Tasks imported successfully!');
                    importTasksModal.hide();
                    fetchTasks(currentFilter); // Refresh tasks after import
                } catch (error) {
                    console.error("Error importing tasks:", error);
                    alert(`Error importing tasks: ${error.message}`);
                }
            });

            // Initial fetch of tasks when the page loads
            if (window.jwt_token) {
                fetchTasks(currentFilter);
            } else {
                document.addEventListener('jwt-ready', () => fetchTasks(currentFilter));
            }
        });
        
        // Expose filterTasks to global scope for onclick events
        window.filterTasks = fetchTasks;
    </script>
{% endblock %}
