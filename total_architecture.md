# Goat System: Отчет об архитектуре

Этот документ представляет детальный анализ архитектуры Goat System, гибридного приложения, сочетающего в себе фронтенд на Flask и бэкенд на FastAPI.

## 1. Общий обзор архитектуры

Goat System — это приложение с несколькими "головами" (точками входа), имеющее четыре основных компонента:

1.  **Веб-приложение Flask**: Отвечает за отдачу HTML-страниц, управляет сессиями пользователей и выступает в роли клиента для бэкенда на FastAPI. Это основной веб-интерфейс для пользователей.
2.  **Приложение FastAPI**: Предоставляет RESTful JSON API для бизнес-логики приложения (управление задачами, привычками и т.д.). Предполагается, что это "бэкенд для фронтенда".
3.  **Telegram-бот**: Предлагает интерфейс для взаимодействия с системой в формате чата, в основном для управления задачами. Он работает независимо от сервиса FastAPI.
4.  **RQ Worker (Фоновый обработчик)**: Фоновый процесс, который выполняет асинхронные задачи, такие как отправка сообщений в Telegram или создание задач, которые ставятся в очередь другими частями системы (в основном ботом).

Вся система построена вокруг единой, общей схемы базы данных, определенной с помощью **Flask-SQLAlchemy**. Эта тесная связь слоя данных с экосистемой Flask является наиболее значимой архитектурной характеристикой, поскольку все четыре компонента зависят от нее, прямо или косвенно.

![Диаграмма архитектуры](https://i.imgur.com/8f1qL3j.png)

*Это упрощенная концептуальная диаграмма. "Контекст приложения Flask" — это не физический сервер, а логическая конструкция, которую процессы бота и обработчика создают для получения доступа к базе данных и конфигурации.*

---

## 2. Компоненты системы

### 2.1. Веб-приложение Flask (Фронтенд-сервер)

-   **Точка входа**: `run.py` (для Gunicorn/WSGI).
-   **Фреймворк**: Flask, Flask-Login.
-   **Обязанности**:
    -   Рендеринг шаблонов Jinja2 для предоставления пользовательского интерфейса.
    -   Управление аутентификацией и сессиями пользователей через Flask-Login.
    -   Для большинства функций (Задачи, Привычки) он действует как чистый клиент, совершая вызовы API к бэкенду FastAPI с помощью клиента на базе `httpx` (`app.api_client`).
    -   **КРИТИЧЕСКИ ВАЖНО**: При регистрации пользователя он обходит API и взаимодействует напрямую с базой данных.
-   **Структура**: Организована в виде "чертежей" (Blueprints) (`auth`, `tasks`, `habits` и т.д.).

### 2.2. Приложение FastAPI (Бэкенд API)

-   **Точка входа**: `main.py` (для Uvicorn/ASGI).
-   **Фреймворк**: FastAPI, Pydantic.
-   **Обязанности**:
    -   Предоставление чистого RESTful JSON API для основных ресурсов приложения.
    -   Обработка аутентификации через JWT (выдача токенов по эндпоинту `/token`).
    -   Обеспечение соблюдения бизнес-логики и валидации данных.
    -   Делегирование всех операций с базой данных сервисному слою (Service Layer).
-   **Структура**: Организована в виде APIRouters (`tasks`, `habits` и т.д.), которые зеркально отражают "чертежи" Flask.
-   **НЕСООТВЕТСТВИЕ**: Отсутствует эндпоинт для создания пользователя, что делает его зависимым от приложения Flask для регистрации пользователей.

### 2.3. Слой данных (Модели и база данных)

-   **Файл определения**: `app/models.py`.
-   **Технология**: SQLAlchemy, но определено и управляется через **Flask-SQLAlchemy**.
-   **Ключевые модели**: `User`, `Task`, `Habit`, `Movie`.
-   **Связанность (Coupling)**: Это ядро системы. Модель `User` имеет прямые зависимости от Flask-Login (`UserMixin`) и Werkzeug (для хеширования паролей). Все остальные компоненты используют эти специфичные для Flask модели для взаимодействия с базой данных. Это мешает сервису FastAPI быть по-настоящему автономным компонентом.

### 2.4. Сервисный слой (Service Layer)

-   **Расположение**: `app/services/`.
-   **Обязанности**: Инкапсулирует всю бизнес-логику и взаимодействия с базой данных. Выступает в роли моста между API/точками входа и моделями данных.
-   **Структура**: Состоит из классов со статическими методами (например, `TaskService`, `HabitService`). Эти сервисы принимают сессию базы данных в качестве аргумента, что позволяет использовать их как в FastAPI (через зависимости), так и в других компонентах (через контекст приложения Flask).
-   **НЕСООТВЕТСТВИЕ**: `UserService` минимален и неполон, в нем отсутствует метод `create_user`. Проверка пароля зависит от `werkzeug`, зависимости Flask.

### 2.5. Фоновые обработчики (RQ & Redis)

-   **Точка входа**: `worker.py`.
-   **Технология**: Redis, RQ (Redis Queue).
-   **Обязанности**: Выполнение длительных или асинхронных задач в фоновом режиме.
-   **Связанность**: Процесс обработчика полностью зависит от приложения Flask. Каждая функция задачи, определенная в `app/tasks_rq.py`, создает новый экземпляр приложения Flask для получения контекста приложения, который необходим для конфигурации и доступа к базе данных. Он не общается с сервисом FastAPI.

### 2.6. Telegram-бот

-   **Точка входа**: `bot.py`.
-   **Технология**: `python-telegram-bot`.
-   **Обязанности**: Предоставление интерфейса на основе чата.
-   **Связанность**: Как и обработчик, бот сильно связан с экосистемой Flask.
    -   Он работает в контексте приложения Flask для получения доступа к базе данных.
    -   Он читает данные напрямую из базы данных, используя `User.query` и `Task.query` (обходя сервисный слой для чтения).
    -   Для операций записи он ставит задачи в очередь для обработчика RQ.
    -   Он не общается с сервисом FastAPI.

---

## 3. Потоки данных и взаимодействия

### Функция: Регистрация нового пользователя

1.  Пользователь отправляет форму на веб-странице **Flask** (`/auth/register`).
2.  Обработчик маршрута Flask получает запрос.
3.  **Он напрямую создает объект модели `User`, хеширует пароль и сохраняет его в базу данных с помощью `db.session.commit()`.**
4.  Сервис FastAPI в этом процессе **не участвует**.

### Функция: Создание задачи через веб-интерфейс

1.  Пользователь отправляет форму на веб-странице **Flask** (`/tasks/create`).
2.  Обработчик маршрута Flask получает запрос.
3.  Обработчик отправляет `POST` запрос на эндпоинт `/tasks/` сервиса **FastAPI**, передавая данные формы в формате JSON.
4.  Эндпоинт FastAPI получает запрос, валидирует данные с помощью схемы Pydantic `TaskCreate`.
5.  Эндпоинт вызывает `TaskService.create_task()`.
6.  `TaskService` создает объект модели `Task` и сохраняет его в базу данных.
7.  Успешный ответ возвращается в Flask, который затем перенаправляет пользователя.

### Функция: Получение списка задач через бота

1.  Пользователь отправляет `/task_list_all` **Telegram-боту**.
2.  Срабатывает обработчик `task_list` в `app/telegram_bot.py`.
3.  Обработчик ставит задачу в очередь для **RQ Worker**: `q.enqueue('app.tasks_rq.handle_task_list', ...)`.
4.  RQ Worker забирает задачу и выполняет функцию `handle_task_list`.
5.  Функция (внутри контекста приложения Flask) вызывает `TaskService.get_tasks_by_user_and_type()` для получения задач из базы данных.
6.  Функция форматирует список задач в строку и ставит в очередь еще одну задачу: `q.enqueue('app.tasks_rq.send_telegram_message', ...)`.
7.  RQ Worker выполняет `send_telegram_message`, которая отправляет итоговое сообщение пользователю через Telegram API.

---

## 4. Архитектурная оценка

Этот отчет служит основой для оценки миграции. Следующим шагом является анализ этих выводов, чтобы дать четкий ответ об успешности миграции и предоставить рекомендации по улучшению.